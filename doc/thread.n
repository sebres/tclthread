'\" 
'\" Copyright (c) 2000 Andreas Kupries
'\" 
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" SCCS: @(#) thread.n
'\"
'\" The definitions below are for supplemental macros used in Tcl/Tk
'\" manual entries.
'\"
'\" .AP type name in/out ?indent?
'\"	Start paragraph describing an argument to a library procedure.
'\"	type is type of argument (int, etc.), in/out is either "in", "out",
'\"	or "in/out" to describe whether procedure reads or modifies arg,
'\"	and indent is equivalent to second arg of .IP (shouldn't ever be
'\"	needed;  use .AS below instead)
'\"
'\" .AS ?type? ?name?
'\"	Give maximum sizes of arguments for setting tab stops.  Type and
'\"	name are examples of largest possible arguments that will be passed
'\"	to .AP later.  If args are omitted, default tab stops are used.
'\"
'\" .BS
'\"	Start box enclosure.  From here until next .BE, everything will be
'\"	enclosed in one large box.
'\"
'\" .BE
'\"	End of box enclosure.
'\"
'\" .CS
'\"	Begin code excerpt.
'\"
'\" .CE
'\"	End code excerpt.
'\"
'\" .VS ?version? ?br?
'\"	Begin vertical sidebar, for use in marking newly-changed parts
'\"	of man pages.  The first argument is ignored and used for recording
'\"	the version when the .VS was added, so that the sidebars can be
'\"	found and removed when they reach a certain age.  If another argument
'\"	is present, then a line break is forced before starting the sidebar.
'\"
'\" .VE
'\"	End of vertical sidebar.
'\"
'\" .DS
'\"	Begin an indented unfilled display.
'\"
'\" .DE
'\"	End of indented unfilled display.
'\"
'\" .SO
'\"	Start of list of standard options for a Tk widget.  The
'\"	options follow on successive lines, in four columns separated
'\"	by tabs.
'\"
'\" .SE
'\"	End of list of standard options for a Tk widget.
'\"
'\" .OP cmdName dbName dbClass
'\"	Start of description of a specific option.  cmdName gives the
'\"	option's name as specified in the class command, dbName gives
'\"	the option's name in the option database, and dbClass gives
'\"	the option's class in the option database.
'\"
'\" .UL arg1 arg2
'\"	Print arg1 underlined, then print arg2 normally.
'\"
'\" RCS: @(#) $Id: thread.n,v 1.8 2002/01/19 23:19:54 vasiljevic Exp $
'\"
'\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
'\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1	\\fI\\$2\\fP	(\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
'\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
'\"	# BS - start boxed text
'\"	# ^y = starting y location
'\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
'\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
'\"	# VS - start vertical sidebar
'\"	# ^Y = starting y location
'\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
'\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
'\"	# Special macro to handle page bottom:  finish off current
'\"	# box/sidebar if in box/sidebar mode, then invoked standard
'\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
'\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
'\"	# DE - end display
.de DE
.fi
.RE
.sp
..
'\"	# SO - start of list of standard options
.de SO
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 4c 8c 12c
.ft B
..
'\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\fBoptions\\fR manual entry for details on the standard options.
..
'\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
'\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
'\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.de UL
\\$1\l'|0\(ul'\\$2
..
.TH "thread" n "TclThread 2.3" Tcl "Tcl Threading"
.BS
'\" Note:  do not modify the .SH NAME line immediately below!
.SH NAME
thread \- Script level threading
.SH "SYNOPSIS"

 Thread manipulation commands:

\fB thread::create\fR ?\fI-joinable\fR? ?\fIscript\fR?
\fB thread::id\fR
\fB thread::errorproc\fR ?\fIprocname\fR?
\fB thread::unwind\fR
\fB thread::exit\fR
\fB thread::names\fR
\fB thread::exists\fR
\fB thread::send\fR \fIid\fR ?\fI-async\fR? \fIscript\fR ?\fIvarname\fR?
\fB thread::wait\fR
\fB thread::join\fR \fIid\fR
\fB thread::transfer\fR \fIid\fR \fIchannel\fR

 Thread synchronization primitives commands:

\fB thread::cond\fR \fIoptions\fR
\fB thread::mutex\fR \fIoptions\fR

 Shared variable commands:

\fB tsv::names\fR ?\fIpattern\fR?
\fB tsv::object\fR \fIarray\fR \fIelement\fR
\fB tsv::set\fR \fIarray\fR \fIelement\fR \fIvalue\fR 
\fB tsv::get\fR \fIarray\fR \fIelement\fR ?\fIvarname\fR?
\fB tsv::unset\fR \fIarray\fR ?\fIelement\fR?
\fB tsv::exists\fR \fIarray\fR ?\fIelement\fR?
\fB tsv::pop\fR \fIarray\fR \fIelement\fR
\fB tsv::move\fR \fIarray\fR \fIold\fR \fInew\fR
\fB tsv::incr\fR \fIarray\fR \fIelement\fR ?\fIincrement\fR?
\fB tsv::append\fR \fIarray\fR \fIelement\fR \fIvalue\fR ?\fIvalue\fR ...?

\fB tsv::lappend\fR \fIarray\fR \fIelement\fR \fIvalue\fR ?\fIvalue\fR ...?
\fB tsv::linsert\fR \fIarray\fR \fIelement\fR \fIindex\fR \fIvalue\fR ?\fIvalue\fR ...?
\fB tsv::lreplace\fR \fIarray\fR \fIelement\fR \fIfirst\fR \fIlast\fR ?\fIvalue\fR ...?
\fB tsv::llength\fR \fIarray\fR \fIelement\fR
\fB tsv::lindex\fR \fIarray\fR \fIelement\fR \fIindex\fR
\fB tsv::lrange\fR \fIarray\fR \fIelement\fR \fIfirst\fR \fIlast\fR
\fB tsv::lsearch\fR \fIarray\fR \fIelement\fR ?\fImode\fR? \fIpattern\fR
\fB tsv::lpop\fR \fIarray\fR \fIelement\fR ?\fIindex\fR?
\fB tsv::lpush\fR \fIarray\fR \fIelement\fR \fIvalue\fR ?\fIindex\fR?
.BE
.SH "DESCRIPTION"
.PP
The \fBthread\fR extension creates threads that contain Tcl interpreters, and
it lets you send scripts to those threads. It also enables you to share data
between threads in a safe, protected fashion and provides script-level access
to basic thread synchronization primitives, like mutexes and condition variables.
.SH COMMANDS
.TP
\fB thread::create\fR ?\fI-joinable\fR? ?\fIscript\fR?
This command creates a thread that contains a Tcl interpreter. 
The Tcl interpreter either evaluates the \fIscript\fR, if
specified, or it waits in the event loop for scripts that arrive via
the \fBthread::send\fR command. The result of \fBthread::create\fR is
the ID of the thread. The result, if any, of \fIscript\fR is
ignored. Using flag \fI-joinable\fR it is possible to create a
joinable thread, i.e. one upon whose exit can be waited upon (by using
\fBthread::join\fR).
.TP
\fBthread::id\fR 
This command returns the ID of the current thread. 
.TP
\fBthread::errorproc\fR 
This command sets a handler for errors that occur in scripts sent 
asynchronously, using the \fI-async\fR flag of the \fBthread::send\fR
command, to other threads. If no handler is specified, the current 
handler is returned. The empty string resets the handler to default 
(unspecified) value.
An uncaught error in a thread causes an error message to be sent
to the standard error channel. This default reporting scheme can be
changed by registering a procedure that is called to report the error.
The \fIproc\fR is called in the interpreter that invoked the 
\fBthread::errorproc\fR command. The \fIproc\fR is called like this:

     myerrorproc thread_id errorInfo
.TP
\fBthread::unwind\fR
This stops a prior \fBthread::wait\fR. Execution of the script will continue
from the \fBthread::wait\fR command. If \fBthread::wait\fR was the last command
in a thread, the thread will exit. The command usually returns empty result but
may trigger Tcl error with the message "target thread died" in some situations.
.TP
\fBthread::exit\fR
This forces a thread stuck in the \fBthread::wait\fR to unconditionaly
exit. This command is guaranteed to leave the program memory in the
unconsistent state, produce memory leaks and otherwise affect other
subsytem(s) of the Tcl application in an unpredictable manner.
Use of this command is deprecated in favour of the \fBthread::unwind\fR.
Use on your own risk and with extreme precaution. The command usually 
returns empty result but may trigger Tcl error with the message 
"target thread died" in some situations.
.TP
\fBthread::names\fR
This command returns a list of thread IDs. These are only for
threads that have been created via \fBthread::create\fR. If your
application creates other threads at the C level, they are not
reported by the \fBthread::names\fR command.
.TP
\fBthread::exists\fR 
Returns true (1) if thread given by the ID parameter exists, false (0)
otherwise. This applies only for threads that have been created via 
\fBthread::create\fR command.
.TP
\fBthread::send\fR
This command passes a \fIscript\fR to another thread and, optionally, waits
for the result. If the \fI-async\fR flag is specified, the command does
not wait for the result and it returns empty string. The target thread must
enter it's event loop in order to receive scripts sent via this command.
This is done by default for threads created without a startup script. Threads
can enter the event loop explicitly by calling \fBthread::wait\fR or 
\fBvwait\fR. 

Optional \fIvarname\fR specifies name of the variable to store
the result of the \fIscript\fR. Without the \fI-async\fR flag, the command
returns the evaluation code, similarily to the standard Tcl \fBcatch\fR command.
If, however, the \fI-async\fR flag is specified, the command returns 
immediately and caller can later \fBvwait\fR on \fIvarname\fR to get the
result of the passed \fIscript\fR.
.TP
\fBthread::wait\fR
This enters the event loop so a thread can receive
messages from \fBthread::send\fR. This is equivalent to \fBvwait\fR 
\fIunusedvariable\fR except that thread::unwind will not unblock
a \fBvwait\fR.
.TP
\fBthread::join\fR 
This command waits for the thread with ID \fIid\fR to exit and
then returns it's exit code. Errors will be returned for threads which
are not joinable or already waited upon by another thread.
.TP
\fBthread::transfer\fR 
This moves the specified \fIchannel\fR from the
current thread and interpreter to the main interpreter of the thread
with the given \fIid\fR. After the move the current interpreter has no
access to the channel anymore, but the main interpreter of the target
thread will be able to use it from now on.
The command waits until the other thread has incorporated the
channel. Because of this it is possible to deadlock the participating
threads by commanding the other through a synchronous
\fBthread::send\fR to transfer a channel to us. This easily extends
into longer loops of threads waiting for each other.
Other restrictions: The channel in question must not be shared among
multiple interpreters running in the sending thread. This
automatically excludes the special channels for standard input, output
and error.
.TP
\fB thread::mutex \fIoptions\fR
This command provides script-level access to mutexes. It supports 
following subcommands and options:
.RS
.TP
\fBthread::mutex create\fR
Creates the mutex and returns it's opaque handle. This handle
should be used for any future reference to the newly created mutex.
.TP
\fBthread::mutex destroy\fR \fImutex\fR
Destroys the mutex \fImutex\fR. Care has to be taken that nobody is 
using the \fImutex\fR, otherwise unexpected errors may happen.
.TP
\fBthread::mutex lock\fR \fImutex\fR
Locks the mutex \fImutex\fR. Locking the mutex may deadlock the program
if same thread attempts to lock the same mutex twice.
.TP
\fBthread::mutex unlock\fR \fImutex\fR
Unlocks the mutex \fImutex\fR so some other thread may lock it.
.RE
.TP
\fB thread::cond\fR \fIoptions\fR
This command provides script-level access to condition variables. It 
supports following subcommands and options:
.RS
.TP
\fBthread::cond create\fR
Creates the condition variable and returns it's opaque handle. This handle
should be used for any future reference to newly created condition variable.
.TP
\fBthread::cond destroy\fR \fIcond\fR
Destroys condition variable \fIcond\fR. Care has to be taken that nobody
is using (i.e. waiting on) the condition variable, otherwise unexpected 
errors may happen.
.TP
\fBthread::cond notify\fR \fIcond\fR
Wakes up all threads waiting on the condition variable \fIcond\fR.
.TP
\fBthread::cond wait\fR \fIcond\fR \fImutex ?\fIms?\fR
This command is used to suspend program execution until the condition
variable \fIcond\fR has been signalled (see \fBthread::cond notify\fR) or the
optional timer has expired. The \fImutex\fR must be locked by the calling
thread on entrance to \fBthread::cond wait\fR. While waiting on the \fIcond\fR,
the command releases \fImutex\fR. Before returning to the calling
thread, the command re-acquires \fImutex\fR again. Unlocking the \fImutex\fR
and waiting on the condition variable \fIcond\fR is done atomically.

The \fIms\fR command option, if given,  must be an integer specifying time 
interval in milliseconds the command waits to be signalled. Otherwise
the command waits forever.

In multithreading programs, there are many situations where a thread has
to wait for some event to happen until it is allowed to proceed.
This is usually accomplished by repeatedly testing a condition under the
mutex protection and waiting on the condition variable until the condition
evaluates to true:

    while {<condition_is_true>} {
        thread::sv_cond wait $cond $mutex
    }

Repeated testing of the condition is needed since the condition variable 
may get signalled without the condition being actually changed (spurious 
thread wake-ups, for example).
.RE
.TP
\fBtsv::names\fR
Returns names of shared arrays matching optional \fIpattern\fR or all known
arrays if pattern is ommited.
.TP
\fBtsv::object\fR
Creates object accessor command for the \fIelement\fR in the given \fIarray\fR.
Using this command, one can apply most of the other shared variable commands
as method functions of the element object command:

    % tsv::set foo bar "A shared string"
    % set string [tsv::object foo bar]
    % $string append " appended"
    => A shared string appended
.TP
\fBtsv::set\fR
Sets the value of the \fIelement\fR  in the shared \fIarray\fR to
\fIvalue\fR and returns the value.
.TP
\fBtsv::get\fR
Gets a value of the \fIelement\fR located in the shared \fIarray\fR.
The command triggers error if the \fIelement\fR is not found.
If the optional \fIvarname\fR is given, the value  is stored in
the named variable. In this case, the command returns true (1) if 
\fIelement\fR is found or false (0) if the \fIelement\fR is not found.
.TP
\fBtsv::unset\fR
Unsets the \fIelement\fR in the shared \fIarray\fR. If the \fIelement\fR
is not given, it unset all elements in the \fIarray\fR and deletes 
the \fIarray\fR.
.TP
\fBtsv::exists\fR
Checks wether the \fIelement\fR exists in the shared \fIarray\fR.
If the \fIelement\fR is not given it tests the existence of the 
\fIarray\fR itself. Returns true (1) if the item exists, 
false (0) if not.
.TP
\fBtsv::pop\fR
Returns value of the \fIelement\fR in the shared \fIarray\fR variable
and unsets the \fIelement\fR in one atomic operation.
.TP
\fBtsv::move\fR
Renames the element \fIold\fR to \fInew\fR in the shared \fIarray\fR.
This effectively performs an get/unset/set sequence of operations
but in one atomic step.
.TP
\fBtsv::incr\fR
Similar to standard Tcl \fBincr\fR but increments the value of the
\fIelement\fR in shared \fIarray\fR instead of the Tcl variable.
.TP
\fBtsv::append\fR
Similar to standard Tcl \fBappend\fR but appends one or more values
to the \fIelement\fR in the shared \fIarray\fR instead of the Tcl variable.
.TP
\fBtsv::lappend\fR
Similar to standard Tcl \fBlappend\fR but appends one or more values
to the list \fIelement\fR in the shared \fIarray\fR instead of the Tcl variable.
.TP
\fBtsv::linsert\fR
Similar to standard Tcl \fBlinsert\fR but inserts one or more values at the 
\fIindex\fR list position in the list \fIelement\fR in the shared \fIarray\fR
instead of the Tcl variable.
.TP
\fBtsv::lreplace\fR
Similar to standard Tcl \fBlreplace\fR but replaces one or more values
from the list \fIelement\fR in the shared \fIarray\fR instead of the Tcl variable.
.TP
\fBtsv::llength\fR
Similar to standard Tcl \fBllength\fR but returns length of the list
\fIelement\fR in the shared \fIarray\fR instead of the Tcl variable.
.TP
\fBtsv::lindex\fR
Similar to standard Tcl \fBlindex\fR but returns value at the \fIindex\fR
list position from the list \fIelement\fR in the shared \fIarray\fR
instead of the Tcl variable.
.TP
\fBtsv::lrange\fR
Similar to standard Tcl \fBlrange\fR but returns values between \fIfirst\fR
and \fIlast\fR list position from the list \fIelement\fR in the shared \fIarray\fR
instead of the Tcl variable.
.TP
\fBtsv::lsearch\fR
Similar to standard Tcl \fBlsearch\fR but searches the list \fIelement\fR
in the shared \fIarray\fR instead of the Tcl variable.
.TP
\fBtsv::lpop\fR
Splices out the value at the \fIindex\fR list position from the list \fIelement\fR
in the shared \fIarray\fR. If \fIindex\fR is not specified, it defaults to zero.
.TP
\fBtsv::lpush\fR
Inserts the \fIvalue\fR at the \fIindex\fR list position in the list \fIelement\fR
in the shared \fIarray\fR. If \fIindex\fR is not specified, it defaults to zero.
.TP
\fBtsv::array\fR
This command supports most of the options of the standard Tcl \fBarray\fR
command like:
.RS
.TP
\fBset\fR
Does the same as standard Tcl \fBarray set\fR
.TP
\fBget\fR
Does the same as standard Tcl \fBarray get\fR
.TP
\fBnames\fR
Does the same as standard Tcl \fBarray names\fR
.TP
\fBsize\fR
Does the same as standard Tcl \fBarray size\fR
.TP
\fBreset\fR
Does the same as standard Tcl \fBarray set\fR but
it clears the array and sets new values atomically.
.RE
.RE
.SH "DISCUSSION"
The fundamental threading model in Tcl is that there can be one or
more Tcl interpreters per thread, but each Tcl interpreter should only
be used by a single thread which created it.
A "shared memory" abstraction is awkward to provide in Tcl because Tcl
makes assumptions about variable and data ownership. Therefore this extension
supports a simple form of threading where the main thread can manage several
background, or "worker" threads. For example, an event-driven server can pass
requests to worker threads, and then await responses from worker threads or 
new client requests. Everything goes through the common Tcl event loop, so 
message passing between threads works naturally with event-driven I/O, 
\fBvwait\fR on variables, and so forth. For the transfer of bulk information
it is possible to move channels between the threads.

In addition, this extension provides simple but effective way of worker
threads to access thread-shared data without the need of explicit locking.
This is implemented with shared variable arrays. Shared variable array
is a data structure similar to Tcl array but internaly protected with mutex. 
Several threads can access array elements without synchronizing themselves.
Script programmer can create any number of such arrays and access them
or their elements from any thread, without explicit locking.

For advanced multithreading scripts, script-level access to two basic 
synchronization primitives, mutex and condition variables, is also supported.
.SH "SEE ALSO"
Guide to the Tcl threading model
.SH "CREDITS"
Shared variable arrays are inspired by the nsv interface found in 
AOLserver 3.+ highly scalable Web server from America Online.
.PP
.SH "KEYWORDS"
threads, events, message passing, synchronization, shared variables,
mutex, condition variable